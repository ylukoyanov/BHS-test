/*
 * КРИТИЧЕСКИЕ ПРОБЛЕМЫ:
 * 1. ПОТОКОБЕЗОПАСНОСТЬ:
 *    - Статическое поле Guests используется без синхронизации
 *    - Операции инкремента и добавления в список не атомарны
 *    - Риск race conditions и исключений "Collection was modified"
 * 
 * 2. ASYNC/await АНТИПАТТЕРНЫ:
 *    - async void методы (CheckAvailability, SaveBooking)
 *    - Использование .Result внутри lock (риск дедлока)
 *    - Lock с async/await - несовместимо
 * 
 * 3. АРХИТЕКТУРА:
 *    - Статическое состояние нарушает инкапсуляцию
 *    - Все экземпляры HotelBooking используют один список гостей
 *    - Отсутствует разделение ответственности
 * 
 * 4. ОТСУТСТВУЮЩИЕ USING-ДИРЕКТИВЫ:
 *    - System.Linq (используется в SaveBooking)
 *    - System.Threading.Tasks (используется Task)
 * 
 * ОСНОВНЫЕ РИСКИ:
 * - Дедлоки при использовании .Result в lock
 * - Race conditions в многопоточной среде
 * - Утечка данных между экземплярами
 * - Необработанные исключения в async void
 * - Неэффективная конкатенация строк
 * 
 * РЕКОМЕНДАЦИИ:
 * - Использовать потокобезопасные коллекции или правильную синхронизацию
 * - Заменить async void на async Task
 * - Использовать await вместо .Result
 * - Использовать SemaphoreSlim для асинхронных блокировок
 * - Сделать Guests нестатическим полем
 * - Добавить валидацию входных параметров
 * - Использовать StringBuilder для конкатенации строк
 * ============================================================================
 */

// Отсутствует: using System.Linq; (используется в методе SaveBooking)
// Отсутствует: using System.Threading.Tasks; (используется Task)
using System.Collections.Generic;
 
namespace BookingSystem;
 
public class HotelBooking
{
    // Непотокобезопасная операция инкремента
    // _currentRoomNumber++ не является атомарной операцией в многопоточной среде
    // Race condition - два потока могут получить одинаковый номер комнаты
    // Использовать Interlocked.Increment или защитить lock'ом
    private int _currentRoomNumber = 0;
    
    // Статическое поле - общее состояние для всех экземпляров класса
    // Все экземпляры HotelBooking используют один и тот же список гостей
    // Утечка данных между разными отелями, проблемы с многопоточностью
    // Нарушение инкапсуляции и принципа единственной ответственности
    // Сделать поле нестатическим или использовать отдельный репозиторий
    private static List<Guest> Guests = new List<Guest>(); 
    
    // Использование null-forgiving operator (null!)
    // Если конструктор не вызовется или параметры будут null, получим NullReferenceException
    // Лучше использовать nullable reference types с проверками или required properties
    private IDatabase _database = null!; 
    private IRoomService _roomService = null!;
    
    // Поле не инициализировано, может быть null
    // NullReferenceException при использовании
    // Сделать readonly и инициализировать в конструкторе, или использовать nullable
    private string _hotelName;
    
    // Статический lock для нестатических операций
    // Блокирует все экземпляры класса, даже если они работают с разными данными
    // Неоправданная блокировка и снижение производительности
    // Использовать нестатический lock для нестатических операций
    private static object _lock = new object();
 
    // Отсутствует валидация входных параметров
    // NullReferenceException при передаче null
    // Пустая строка для name может быть недопустимой
    // Добавить проверки и выбросить ArgumentNullException/ArgumentException
    // Поля _database и _roomService не readonly
    // Могут быть изменены после создания объекта, нарушая инварианты
    // Сделать readonly для обеспечения неизменности после инициализации
    public HotelBooking(string name, IDatabase db, IRoomService roomService)
    {
        _hotelName = name;
        _database = db;
        _roomService = roomService;
    }
 
    // Метод не является потокобезопасным
    // Операции _currentRoomNumber++ и Guests.Add не атомарны
    // Race condition - два потока могут:
    //   1. Получить одинаковый номер комнаты
    //   2. Добавить гостя в неправильном порядке
    //   3. Получить некорректное состояние данных
    // Обернуть весь метод в lock или использовать потокобезопасные коллекции
    
    // Отсутствует валидация параметра
    // NullReferenceException при передаче null
    // Гость может быть добавлен с некорректными данными (пустое имя и т.д.)
    // Добавить проверку на null и валидацию данных гостя
    
    // Логическая ошибка в порядке операций
    // Номер комнаты инкрементируется ДО добавления гостя
    // Если Add() выбросит исключение, номер комнаты уже будет увеличен
    // Если гость уже имеет RoomNumber, он будет перезаписан
    // Проверить, не установлен ли уже RoomNumber, или изменить порядок операций
    
    // Нет проверки на дубликаты
    // Один и тот же гость может быть добавлен несколько раз
    public void RegisterGuest(Guest g)
    {
        _currentRoomNumber++;
        Guests.Add(g);
        g.RoomNumber = _currentRoomNumber;
    }
 
    // async void - антипаттерн
    // Исключения в async void методах не могут быть перехвачены вызывающим кодом
    // Необработанные исключения могут привести к краху приложения
    // Невозможно await этот метод, нельзя дождаться завершения
    // Изменить на async Task или async Task<bool>
    
    // Использование .Result внутри lock
    // .Result блокирует текущий поток, ожидая завершения Task
    // Если Task выполняется в том же контексте синхронизации (например, UI поток), и ожидает освобождения lock, который удерживается текущим потоком - дедлок
    // Блокировка потока снижает производительность
    // Использовать await вместо .Result, убрать lock (если не нужен) или использовать SemaphoreSlim
    
    // Lock используется для защиты асинхронной операции
    // Lock не предназначен для асинхронного кода
    // Может привести к проблемам с производительностью и дедлокам
    // Использовать SemaphoreSlim.WaitAsync() для асинхронных блокировок
    
    // Отсутствует валидация roomId
    // Отрицательные или некорректные значения могут привести к неожиданному поведению
    
    // Использование базового Exception
    // Лучше использовать специализированные исключения (InvalidOperationException, ArgumentException)
    // Лучше добавить информативное сообщение с деталями (roomId, hotelName)
    
    // Метод ничего не возвращает
    // Должен ли метод возвращать bool или выбрасывать исключение?
    // Рассмотреть возврат Task<bool> вместо void
    public async void CheckAvailability(int roomId)
    {
        lock (_lock)  // Lock с async/await - риск дедлока
        {
            // .Result блокирует поток - может вызвать дедлок
            // Если IsAvailable выполняется в том же контексте синхронизации - дедлок
            var available = _roomService.IsAvailable(roomId).Result; 
            if (!available)
                throw new Exception("Room is not available!");  // ЛУЧШЕ: специализированное исключение
        }
    }
 
    // async void - антипаттерн (см. комментарии выше)
    // Изменить на async Task
    
    // Непотокобезопасный доступ к статическому списку Guests
    // Метод читает Guests без синхронизации
    // Если другой поток изменяет Guests во время выполнения Select().ToList(), может произойти исключение или получение некорректных данных
    // Collection was modified during enumeration - InvalidOperationException
    // Использовать lock или потокобезопасную коллекцию, или создать snapshot списка
    
    // Отсутствует обработка исключений
    // Исключения из SaveAsync не обрабатываются
    // В async void исключения могут привести к краху приложения
    // Добавить try-catch или изменить сигнатуру на async Task
    
    // Отсутствует валидация данных перед сохранением
    // Может быть сохранена некорректная информация (пустое имя отеля, пустой список)
    // Добавить проверки перед сохранением
    
    // Использование анонимного типа для передачи данных
    // Лучше создать DTO класс для явного контракта данных
    
    // Отсутствует using для System.Linq
    // Код не скомпилируется без using System.Linq;
    public async void SaveBooking()
    {
        // Guests может быть изменен другим потоком во время выполнения
        var data = new
        {
            Hotel = _hotelName,
            Guests = Guests.Select(g => new { g.Name, g.RoomNumber }).ToList()  // НЕ ПОТОКОБЕЗОПАСНО
        };

        await _database.SaveAsync(data);  // Нет обработки исключений
    }
 
    // Непотокобезопасный доступ к статическому списку
    // Метод читает Guests без синхронизации
    // Collection was modified during enumeration - InvalidOperationException
    // Если другой поток изменяет Guests во время foreach, получим исключение
    // Использовать lock или создать snapshot списка
    
    // Неэффективная конкатенация строк в цикле
    // string += создает новый объект строки на каждой итерации
    // O(n^2) сложность по времени и памяти, неэффективно
    // Использовать StringBuilder или string.Join()
    
    // Отсутствует проверка на null
    // Если g.Name == null, будет добавлен "null" в строку
    // Если Guests содержит null элементы, получим NullReferenceException
    // Добавить проверки на null и фильтрацию
    
    // Отсутствует разделитель между именами
    // Использовать string.Join(", ", ...) для читаемости
    
    // Лишний пробел перед return
    // "return  result;" должно быть "return result;"
    
    // Статический метод работает с общим состоянием
    // Нарушает принцип инкапсуляции
    // Все экземпляры HotelBooking используют один список
    public static string GetAllGuestNames()
    {
        string result = "";  // Используйте StringBuilder
        foreach (var g in Guests)  // нужен lock или snapshot, не потокобезопасный доступ
            result += g.Name;  // создает новый объект на каждой итерации, неэффективно
                              // g или g.Name могут быть null

        return  result;  // лишний пробел
    }
}
 
// Класс Guest - мутабельный (изменяемый)

// Отсутствует валидация свойств
// Name может быть null или пустой строкой
// RoomNumber может быть отрицательным или нулевым
// Добавить валидацию в setters или использовать конструктор с валидацией

// Отсутствует переопределение Equals/GetHashCode
// Два гостя с одинаковыми данными не будут считаться равными
// Проблемы при использовании в HashSet, Dictionary и т.д.
// Реализовать Equals и GetHashCode, если важна семантика равенства

// Отсутствует переопределение ToString()
// Добавить для удобства отладки и логирования

// Отсутствует конструктор
// Добавить конструктор для обеспечения корректной инициализации
public class Guest
{
    // Name может быть null
    // Использовать nullable reference types или валидацию
    public string Name { get; set; }
    
    // RoomNumber может быть некорректным (0, отрицательное)
    // Добавить валидацию в setter
    public int RoomNumber { get; set; }
}
 
// Использование object в качестве параметра
// Отсутствует типобезопасность
// Можно передать любой объект, что может привести к ошибкам во время выполнения
// Использовать generic-тип или конкретный DTO класс

// Отсутствует CancellationToken
// Невозможно отменить длительную операцию
// Добавить CancellationToken параметр
// Task SaveAsync(object data, CancellationToken cancellationToken = default)

// Отсутствует информация о возможных исключениях
// Документировать, какие исключения может выбрасывать метод
public interface IDatabase
{
    Task SaveAsync(object data);  // ЛУЧШЕ: generic или DTO, добавить CancellationToken
}

// Отсутствует валидация параметра в интерфейсе

// Отсутствует CancellationToken
// Невозможно отменить проверку доступности
// Добавить CancellationToken параметр

// Название метода может быть неоднозначным
public interface IRoomService
{
    Task<bool> IsAvailable(int roomId);  // добавить CancellationToken, документировать валидацию
}